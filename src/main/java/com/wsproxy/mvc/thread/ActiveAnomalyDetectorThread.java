package com.wsproxy.mvc.thread;

import com.wsproxy.anomalydetection.AnomalyScanRequest;
import com.wsproxy.anomalydetection.DetectedAnomaly;
import com.wsproxy.anomalydetection.DetectionLibrary;
import com.wsproxy.anomalydetection.DetectionType;
import com.wsproxy.httpproxy.trafficlogger.WebsocketTrafficRecord;
import com.wsproxy.logging.AppLog;
import com.wsproxy.mvc.model.MainModel;
import com.wsproxy.projects.ProjectDataServiceException;

import java.io.IOException;
import java.util.ArrayList;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;
/*
    Runs on one or more conversations
    - Only tests generated by these rules will be checked by these rules
    - Good for blind tests, oob tests ( interact-sh, oast etc )
 */
public class ActiveAnomalyDetectorThread extends Thread {
    private Logger LOGGER = AppLog.getLogger(ActiveAnomalyDetectorThread.class.getName());
    boolean shutdownRequested = false;
    private DetectionLibrary detectionLibrary = null;
    private MainModel mainModel;
    public ActiveAnomalyDetectorThread(MainModel mainModel) {
        this.mainModel = mainModel;
        detectionLibrary = new DetectionLibrary(DetectionType.PASSIVE);
    }
    public void shutdown() {
        shutdownRequested = true;
    }

    private ArrayList<WebsocketTrafficRecord> getTrafficRecords(String testSequenceId ) {
        ArrayList<WebsocketTrafficRecord> records = new ArrayList<>();
        try {
            records.addAll(mainModel.getProjectModel().getProjectDataService().getWebsocketTrafficRecordByConversationUUID(testSequenceId));
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ProjectDataServiceException e) {
            e.printStackTrace();
        }
        return records;
    }

    public ArrayList<ArrayList<WebsocketTrafficRecord>> loadConversations( String conversationUuids[] ) {
        ArrayList<ArrayList<WebsocketTrafficRecord>> conversations = new ArrayList<ArrayList<WebsocketTrafficRecord>>();
        for ( String convoId  : conversationUuids ) {
            ArrayList<WebsocketTrafficRecord> websocketTrafficRecords = getTrafficRecords(convoId);
            conversations.add(websocketTrafficRecords);
        }
        return conversations;
    }
    public void run() {
        DetectionLibrary detectionLibrary = new DetectionLibrary(DetectionType.ACTIVE);
        detectionLibrary.load();
        LOGGER.info("Active anomaly detector started");
        while ( !shutdownRequested ) {
            try {
                AnomalyScanRequest anomalyScanRequest = (AnomalyScanRequest) mainModel.getProjectModel().getActiveAnomalyScanQueue().poll(1, TimeUnit.SECONDS);
                if ( anomalyScanRequest != null ) {
                    LOGGER.info(String.format("Processing batch %s/%d - %d conversations", anomalyScanRequest.getTestName(),anomalyScanRequest.getRuleId(), anomalyScanRequest.getConversationUuids().size()));
                    ArrayList<ArrayList<WebsocketTrafficRecord>> conversations = loadConversations(anomalyScanRequest.getConversationUuids().toArray(new String[0]));
                    ArrayList<DetectedAnomaly> anomalies = detectionLibrary.detectAnomalies(conversations,anomalyScanRequest.getTestName(),anomalyScanRequest.getRuleId());
                    if ( anomalies != null ) {
                        mainModel.getProjectModel().getDetectedAnomalies().addAll(anomalies);
                        for ( DetectedAnomaly anomaly : anomalies ) {
                            LOGGER.info(String.format("Logged anomaly %s for sequence %s", anomaly.getAnomalyId(), anomaly.getConversationUuid()));
                            mainModel.getAnomaliesModel().addAnomaly(anomaly);
                        }
                    }
                }
                Thread.sleep(100);
            } catch (InterruptedException e) {

            }
        }
        LOGGER.info("Active anomaly detector stopped");
    }
}